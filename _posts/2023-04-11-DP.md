---
layout: single  
title:  "(8) DP"
categories: Coding_Test
tag: [Climbing Stairs, Coin Change, Unique Paths, Min Cost Climbing Stairs]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---

### DPë€? ë¬¸ì œì— ëŒ€í•œ ì •ë‹µì´ ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” <u>ëª¨ë“  í•´ê²°ì±…ì„ <span style='background-color:#F7DDBE'>(ì™„ì „íƒìƒ‰ì¸ë°)</span>, "ì²´ê³„ì "ì´ê³  "íš¨ìœ¨ì "ìœ¼ë¡œ íƒìƒ‰</u>í•˜ëŠ” í’€ì´ë²•ì„ ë§í•©ë‹ˆë‹¤.
<img src="/assets/images/2023-04-11-DP/definition.png" alt="DPë€?" style="zoom:60%;" /> <br/>

#### - Overlapping subproblem  
#### - Optimal substructure

ìœ„ì— ë‘ ê°€ì§€ ì¡°ê±´ì´ ì„±ë¦½í•˜ë©´ DP ë¬¸ì œì…ë‹ˆë‹¤.  

DPëŠ” ì–´ë ¤ìš´ ê°œë…ì€ ì•„ë‹ˆì§€ë§Œ, DPì¸ì§€ ì•Œì•„ì°¨ë¦¬ëŠ” ê²Œ ì–´ë µê¸° ë•Œë¬¸ì—, ë§ì€ ìœ í˜•ì„ ì ‘í•˜ë©´ì„œ ì²´í™”í•˜ëŠ”ê²Œ ì¢‹ìŠµë‹ˆë‹¤.   
<br/>

### 1. êµ¬í˜„ ë°©ë²• : Top down vs Bottom up
**<u>DPë¥¼ <span style='background-color:#F7DDBE'>ì¬ê·€ë¡œ</span> êµ¬í˜„í•˜ë©´ Top-downì´ê³ ,   
<span style='background-color:#F7DDBE'>ë°˜ë³µë¬¸ìœ¼ë¡œ</span> êµ¬í˜„í•˜ë©´ Bottom-upì…ë‹ˆë‹¤.</u>**  

DPëŠ” ì¬ê³„ì‚°ì„ í•˜ì§€ ì•ŠëŠ” ê²ƒì´ë©°, ë©”ëª¨ë¦¬ì— ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.  

Top-down ë°©ì‹ì€ ë©”ëª¨ì´ì œì´ì…˜(memoization),    
Bottom-up ë°©ì‹ì€ tabulation(DP table)ì´ë¼ê³  ë§ì´í•¨.

memoizationê³¼ tabulationì€ ì°¨ì´ê°€ ì—†ê³ , DP ë°©ì‹ì— ë”°ë¥¸ ëª…ì¹­ ì°¨ì´ì…ë‹ˆë‹¤.  êµ¬í˜„ì€ dictionaryë‚˜ listë¡œ í•©ë‹ˆë‹¤.   
#### (1) ë¹„êµ
<img src="/assets/images/2023-04-11-DP/Comparison.png" alt="íƒ‘ë‹¤ìš´vsë°”í…€ì—…" style="zoom:60%;" />

ì´ë ‡ê²Œ ì§œë©´, ì¢€ ì‰½ìŠµë‹ˆë‹¤.  
**<u><span style="color:#ff0000">(1) ì™„ì „íƒìƒ‰(ì¬ê·€)ë¡œ ì§œê³  -> (2) Memoizationìœ¼ë¡œ Top-down êµ¬í˜„     
(3) Stackoverflow ë“± ë¬¸ì œê°€ ìƒê¸°ë©´ Bottom-upìœ¼ë¡œ ë°”ê¿”ì„œ êµ¬í˜„</span></u>**        

#### (2) ì˜ˆì œ : í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´  

í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ ë¬¸ì œë¥¼ ì˜ˆì‹œë¡œ ë³´ê² ìŠµë‹ˆë‹¤.   

- ì¬ê·€(DFS)ë¡œ í’€ë©´? O(2^n)
```python
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n-1) + fibo(n-2)
```

DPë¡œ í’€ë©´, **<u>ì‹œê°„ë³µì¡ë„ë¥¼ O(n)ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (execution treeë¥¼ ë³´ë©´ 2n)</u>** ì¤‘ë³µëœ ë¬¸ì œë¥¼ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ì—¬ ì¬ê³„ì‚°ì„ ë§‰ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.  
<img src="/assets/images/2023-04-11-DP/DP.png" alt="DP" style="zoom:60%;" />

- **<u>Top-down DPë¡œ í’€ë©´?</u>** O(n) 
```python
memo = {1: 1, 2: 1} 
def fibo(n):
    if n not in memo:
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]
```
ì¬ê·€ë¥¼ í™œìš©í•´ì„œ **<u>ìœ„ì—ì„œë¶€í„° ì•„ë˜ë¡œ ë‚˜ëˆ ì„œ êµ¬í•˜ëŠ” í˜•íƒœ</u>**ì´ì§€ë§Œ,  
ì‹¤ì œë¡œëŠ” ì•„ë˜ì—ì„œë¶€í„° ì±„ì›Œì ¸ ë”í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.   


- **<u>Bottom-up DPë¡œ í’€ë©´?</u>** O(n)   
```python
def fibo(n): 
    dp = {1: 1, 2: 1}
    for i in range(3, n+1):         # for loop
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```
ë©”ëª¨ë¦¬ì— ì²˜ìŒ(base case)ë¶€í„° ì‹œì‘(ì €ì¥)í•´ì„œ, 
**<u>ë©”ëª¨ë¦¬ì— ì €ì¥ëœ ê°’ì„ êº¼ë‚´ì„œ ë”í•˜ëŠ”</u>** ë°©ì‹ì…ë‹ˆë‹¤. 

<br/>


### 2. DP Summary

ë¬¸ì œ í’€ë©´ì„œ, ê°œë…ë„ì˜ ì´í•´ë¥¼ ì²´í™”í•˜ëŠ” ë°˜ë³µ ê³¼ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. 
<img src="/assets/images/2023-04-11-DP/Summary.png" alt="DP_Summary" style="zoom:60%;" />


*ë¶„í• ì •ë³µì€, ë¯¸ë˜ì˜ ê³„ì‚°ì´ ì•ì„  ê³„ì‚° ê²°ê³¼ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ë‹¤ëŠ” ì ì—ì„œ DPì™€ ë‹¤ë¦…ë‹ˆë‹¤.*

<br/>


### 3. DP ì˜ˆì œ

DPëŠ” ì´ë¡  ì´í•´ë³´ë‹¤ëŠ” DPì„ì„ ì•Œì•„ì°¨ë¦¬ê°€ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì œë¥¼ í™•ì¸í•´ë³´ê² ìŠµë‹ˆë‹¤.   

#### ğŸ“ [Climbing Stairs ë¬¸ì œ](https://leetcode.com/problems/climbing-stairs/)
- ì œí•œì‚¬í•­ : 1 <= n <= 45   

- **<u>ì¬ê·€ë¡œ í’€ë©´?</u>**       
<img src="/assets/images/2023-04-11-DP/sol1(1).png" alt="Climbling Strairs ë¬¸ì œ" style="zoom:30%;" />

```python
class Solution:s
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2

        return climbStairs(n-1) + climbStairs(n-2)     
```

- **<u>Top-down DPë¡œ í’€ë©´?</u>**  

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        memo = {1 : 1, 2 : 2}
        def cs(n):
            if n not in memo:
                memo[n]= cs(n-1) + cs(n-2)
            return memo[n]
        
        return cs(n)
```

- **<u>Bottom-up DPë¡œ í’€ë©´?</u>**  

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = {1 : 1, 2 : 2}
        for i in range(3,n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
```
<br/>

#### ğŸ“ [Coin Change ë¬¸ì œ â­](https://leetcode.com/problems/coin-change/)
- ì œí•œì‚¬í•­ : 0 <= amount <= 10^4, 1 <= coins.length <= 12        
- ì˜ˆì™¸ì²˜ë¦¬ : 1 <= coins[i] <= 2^31 - 1       
- ì ‘ê·¼ë°©ë²• : dp[i]ëŠ” iì›ì„ ëª¨ìœ¼ê¸° ìœ„í•´ í•„ìš”í•œ ë™ì „ ê°œìˆ˜     
- **<u>Bottom-up DP</u>** : ë°°ìˆ˜ì˜ ê´€ê³„ê°€ ì•„ë‹ ìˆ˜ ìˆìœ¼ë¯€ë¡œ greedyë¬¸ì œê°€ ì•„ë‹Œ DPë¬¸ì œì…ë‹ˆë‹¤.    
- ì‹œê°„ë³µì¡ë„ : O(n) = O(10^4)    

```python
class Solution:
    def coinChange(self, coins, amount: int) -> int:
        dp = [2**31]*(amount+1)
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin]+1)
        
        if dp[amount] == 2**31:
            return -1

        return dp[amount]

sol = Solution()
print(sol.coinChange([1,3,5], 7))
```

<details>
<summary>[(ë²ˆì™¸) ë™ì „ ë°°ìˆ˜ ë¬¸ì œ ì ‘ê¸°/í¼ì¹˜ê¸°]</summary>
<div markdown="1">

#### ğŸ“ (ë²ˆì™¸) [11047ë²ˆ: ë™ì „ 0](https://www.acmicpc.net/problem/11047)

ë™ì „ì´ ë°°ìˆ˜ ê´€ê³„ë¼ê³  í•œë‹¤ë©´, ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ì—†ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•©ë‹ˆë‹¤.  

```python
## ë°±ì¤€ Style
# n, amount = map(int, input().split())
# coins = []
# for i in range(n):
#     coins.append(int(input()))
result = 0
coins = coins[::-1]     # ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
for i in range(n):
        if amount // coins[i] > 0:
            result += amount // coins[i]
            amount = amount % coins[i]
return result
```
</div>
</details>

<br/>

#### ğŸ“ [Unique Paths ë¬¸ì œ](https://leetcode.com/problems/unique-paths/submissions/)

- ì œí•œ ì‚¬í•­ : í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ ë‹µì´ 2*10^9 = n
- ì ‘ê·¼ ë°©ë²• : ì™„ì „ íƒìƒ‰ìœ¼ë¡œ í’€ë©´ ì‹œê°„ë³µì¡ë„ ì´ˆê³¼ì´ë„¤? ê·¸ëŸ¬ë©´, ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ DPë¡œ í’€ê¹Œ?  

í—·ê°ˆë¦¬ë„¤ìš”, **<span style='background-color:#F7DDBE'>Top-downê³¼ Bottom-upì€ ì™„ì „íƒìƒ‰ ì•„ë‹™ë‹ˆë‹¤! ì™„ì „íƒìƒ‰(BFS,DFS)ì˜ ì‹œê°„ë³µì¡ë„ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ Memoizationí•˜ëŠ” ë°©ë²•</span>** ì…ë‹ˆë‹¤.  

- **<u>DFS ì™„ì „íƒìƒ‰</u>** ìœ¼ë¡œ í’€ë©´?  

ì‚¬ì‹¤, ìˆ˜í•™ì ìœ¼ë¡œ ì ‘ê·¼í•˜ë©´ ìˆ˜ì‹ìœ¼ë¡œ ë°”ë¡œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
(m+n-2)C(m-1) = (198)C(99) , ê·¸ë˜ì„œ ë¬¸ì œì—ì„œ 2*10^9 ì´ë ‡ê²Œ ì œí•œì‚¬í•­ìœ¼ë¡œ ì£¼ì—ˆë„¤ìš”!     

Graphì—ì„œ DFSë‘ ë¹„ìŠ·í•œë°, ë‹¤ë§Œ ê²½ìš°ì˜ ìˆ˜ êµ¬í•˜ê¸° ë¬¸ì œì´ë¯€ë¡œ visited ì“°ë©´ ì•ˆë©ë‹ˆë‹¤.

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        def dfs(x, y):
            if x == n and y == m:
                return 1
            count = 0
            if x+1 < n:
                count += dfs(x+1,y)
            if y+1 < m:
                count += dfs(x,y+1)
            return count
```

**DPë¡œ í’€ë©´, O(M*N)ì…ë‹ˆë‹¤.**  êµ‰ì¥íˆ ê°•ë ¥í•œ ì•Œê³ ë¦¬ì¦˜ì´ë„¤ìš”!   
í’€ì´ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.    

- **<u>Top-down</u>** ìœ¼ë¡œ í’€ë©´?

ê°€ì¥ìë¦¬ëŠ” 1ë¡œ ì´ˆê¸°í™”í•˜ê³  ìˆ˜í–‰í•˜ì˜€ìŠµë‹ˆë‹¤.  

```python       
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        memo = {}
        for y in range(m):
            memo[(0,y)] = 1
        for x in range(n):
            memo[(x,0)] = 1
        
        def pathCount(coordinate):
            if coordinate not in memo:
                x, y = coordinate
                memo[(x,y)] = pathCount((x,y-1)) + pathCount((x-1,y))
            return memo[coordinate]
        
        return pathCount((n-1,m-1))
```

- **<u>Bottom-up</u>** ìœ¼ë¡œ í’€ë©´?

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = {}
        for y in range(m):
            dp[(0,y)] = 1
        for x in range(n):
            dp[(x,0)] = 1
            
        for x in range(1,n):
            for y in range(1,m):
                dp[(x,y)] = dp[(x-1,y)] + dp[(x,y-1)] 
                
        return dp[(n-1,m-1)]
```


<br/>

#### ğŸ“ [Min Cost Climbing Stairs ë¬¸ì œ](https://leetcode.com/problems/min-cost-climbing-stairs/)

- ì œí•œ ì‚¬í•­ : 2 <= cost.length <= 1000
- ì‹œê°„ ë³µì¡ë„ : O(n)

- **<u>DFS ì™„ì „íƒìƒ‰</u>** ìœ¼ë¡œ í’€ë©´? 
```python
def dfs(n):
    if n == 0 and n ==1:
        return 0
    return min(dfs(n-1)+cost[n-1], dfs(n-2)+cost[n-2])
```
í•˜ì§€ë§Œ, DFSë¡œ í’€ë©´ O(2^n)ì´ë¯€ë¡œ ì‹œê°„ì´ˆê³¼ê°€ ê±¸ë¦½ë‹ˆë‹¤. 
<br/>

- **<u>Top-down</u>** ìœ¼ë¡œ í’€ë©´?
<!-- ```python
memo = {}
def costUpdate(n):
    if n == 0 and n == 1:
        return 0 
    if n not in memo:
        memo[n] = min(costUpdate(n-1)+cost[n-1], costUpdate(n-2)+cost[n-2])
    return memo[n]
``` -->
<br/>

- **<u>Bottom-up</u>** ìœ¼ë¡œ í’€ë©´?
```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost) 
        cost.append(0)
        dp = {0: cost[0], 1: cost[1]}
        for i in range(2,n+1):
            dp[i] = min(dp[i-1], dp[i-2])+cost[i]
        return dp[n]
```
<br/>

ë‹¤ìŒì—ëŠ” í™/ìš°ì„ ìˆœìœ„ í ì— ëŒ€í•´ì„œ í¬ìŠ¤íŒ… í•˜ê² ìŠµë‹ˆë‹¤ :) 

*í•´ë‹¹ ì‹œë¦¬ì¦ˆì˜ í¬ìŠ¤íŠ¸ëŠ” [ì¸í”„ëŸ°ì—ì„œ ì œê³µí•˜ëŠ” ê°œë°œë‚¨ë…¸ì”¨ì˜ ì½”ë”©í…ŒìŠ¤íŠ¸ ê°•ì˜](https://www.inflearn.com/course/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%85%EB%AC%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC) ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.*