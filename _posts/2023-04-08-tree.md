---
layout: single  
title:  "Tree"
categories: Coding_Test
tag: [BFS, DFS, factorial, fibonacci, Lowest Common Ancestor, Maximum Depth]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---

### TreeëŠ” Nodeì˜ <u>ê³„ì¸µí˜• ìë£Œêµ¬ì¡°</u>ë¡œì¨, rootì™€ ë¶€ëª¨-ìì‹ ê´€ê³„ì˜ <u>subtreeë¡œ êµ¬ì„±</u>ë˜ì–´ ìˆìŠµë‹ˆë‹¤.   

### Tree Traversal(ìˆœíšŒ)ì€ BFS, DFSë¡œ ë‚˜ë‰©ë‹ˆë‹¤.

### <u>BFSëŠ” í</u>ë¡œ êµ¬í˜„ë˜ë©°, <u>DFSëŠ” ë°˜ë³µë¬¸+stack í˜¹ì€ recursion</u>ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤.    

BFSì™€ DFSì— ë“¤ì–´ê°€ê¸° ì•ì„œ, ë¨¼ì € recursionê³¼ ì´ì§„íŠ¸ë¦¬(binary tree)ì— ëŒ€í•´ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.    
#### (1) Recursion  
ì¬ê·€í•¨ìˆ˜ëŠ” (1) ì í™”ì‹ì— recurrence relationì´ ìˆì–´ì•¼ í•˜ë©° (2) ì¬ê·€ í˜¸ì¶œì— ë¹ ì ¸ë‚˜ì˜¬ ì¡°ê±´ì¸ base caseê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.     
ëŒ€í‘œì ì¸ ì¬ê·€í•¨ìˆ˜ë¡œëŠ” factorialê³¼ fibonacciê°€ ìˆìŠµë‹ˆë‹¤.     
<img src="/assets/images/2023-04-08-tree/recursive.png" alt="ì¬ê·€í•¨ìˆ˜" style="zoom:80%;" /> <br/>

##### Recursionì˜ ì‹œê°„ë³µì¡ë„

<img src="/assets/images/2023-04-08-tree/recursive_bigO.png" alt="BigO" style="zoom:50%;" />
<img src="/assets/images/2023-04-08-tree/fibo.png" alt="fibo" style="zoom:30%;" /> <br/>

- factorial ì í™”ì‹ì€ O(n)ì´ê³ , factorial() í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„ì™€ ê³±í•œ ê°’ì´ ìµœì¢… ì‹œê°„ë³µì¡ë„ì…ë‹ˆë‹¤.  
- fibonacci ì í™”ì‹ì€ O(2^n)ì´ê³ , fibonacci() í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„ì™€ ê³±í•œ ê°’ì´ ìµœì¢… ì‹œê°„ë³µì¡ë„ì…ë‹ˆë‹¤.   

#### (2) ì´ì§„íŠ¸ë¦¬ (Binary Tree)

Treeì—ì„œ degreeë€, ë…¸ë“œì˜ ì°¨ìˆ˜ë¥¼ ë§í•˜ê³     
ëª¨ë“  ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ nê°œ ì´í•˜ì¸ íŠ¸ë¦¬ë¥¼, "nì§„ íŠ¸ë¦¬"ë¼ê³  í•©ë‹ˆë‹¤.  

ì—¬ê¸°ì—ì„œ, ëª¨ë“  ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ 2ê°œì´ë©´ ì™„ì „ì´ì§„íŠ¸ë¦¬(complete binary tree)ë¼ê³  í•˜ë©°, ì´ëŠ” heap ìë£Œêµ¬ì¡°ì—ì„œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
<img src="/assets/images/2023-04-08-tree/binaryTree.png" alt="ì´ì§„íŠ¸ë¦¬" style="zoom:80%;" /> <br/>

---
ì—„ë°€íˆ ë§í•˜ë©´, **<u>íŠ¸ë¦¬ì—ì„œëŠ” BFS, DFSê°€ ì—†ê³  level order, post order</u>**ë¼ê³  í•©ë‹ˆë‹¤.  
í•˜ì§€ë§Œ, ê°œë…ì´ ê°™ê¸° ë•Œë¬¸ì— íŠ¸ë¦¬ì—ì„œë„ í¸ì˜ìƒ BFSì™€ DFSë¼ê³  í•˜ê² ìŠµë‹ˆë‹¤.

#### (3) BFS by Queue

ì•ì„œ ì„¤ëª…í•œ, treeë¥¼ ìˆœíšŒí•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ë¡œ íŠ¸ë¦¬ì˜ ìƒìœ„ ë ˆë²¨ë¶€í„° í•˜ë‚˜ì”© ìˆœíšŒí•˜ëŠ” **<u>level order</u>** ë°©ë²•ì…ë‹ˆë‹¤.  

í…œí”Œë¦¿ì²˜ëŸ¼ ì™¸ì›Œì•¼í•©ë‹ˆë‹¤!!
```python
# ê°€ì¥ ê°„ë‹¨í•œ BFS, ë°©ë¬¸ìˆœì„œ listë¡œ ë³€í™˜í•´ì£¼ê¸°
from collections import deque

def bfs(root):
    visited = []
    if root is None: return []
    q = deque()
    q.append(root)
    while q:
        cur_node = q.popleft()          # ì ‘ê·¼(access)
        visited.append(cur_node.value)  # ë°©ëª…ë¡ ë‚¨ê¸°ê¸°, ë°©ë¬¸ (íŠ¸ë¦¬ì—ì„œ visitiedëŠ” í•„ìˆ˜ê°€ ì•„ë‹˜!)

        if cur_node.left:
            q.append(cur_node.left)
        if cur_node.right:
            q.append(cur_node.right)
    return visited
```

#### (4) DFS by Recursion
DFSë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì€ 2ê°€ì§€ ì…ë‹ˆë‹¤.  
- stack + ë°˜ë³µë¬¸  
- ì¬ê·€  

ì¬ê·€ë¡œ ì§¤ ê²½ìš° ì½”ë“œê°€ ê°„ë‹¨í•´ì§€ë¯€ë¡œ, ì¬ê·€ë¡œ ì§œëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ê² ìŠµë‹ˆë‹¤.   

```python
def dfs(root):
    if root is None:    # base case
        return
    dfs(root.left)      # subtreeì˜ ìƒˆë¡œìš´ rootê°€ ë¨.
    dfs(root.left)

dfs(root)
```

##### 1. ì ‘ê·¼ê³¼ ë°©ë¬¸ì€ ë‹¤ë¥´ë‹¤
**<u>Treeë¥¼ ìˆœíšŒí•œë‹¤ëŠ” ê²ƒì€ ì ‘ê·¼í•˜ì—¬ ë°©ë¬¸</u>**í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.   
í—·ê°ˆë¦¬ì§€ ë§™ì‹œë‹¤! ì ‘ê·¼(access)ê³¼ ë°©ë¬¸ì€ ë‹¤ë¦…ë‹ˆë‹¤. ë³´í†µ, DFSì—ì„œëŠ” ì ‘ê·¼ì„ ì—¬ëŸ¬ë²ˆ í•˜ê²Œ ë˜ê³ , ë°©ë¬¸ì€ í•œ ë²ˆ í•˜ê²Œ ë©ë‹ˆë‹¤. ë°©ë¬¸ì€ ì–´ë–¤ ì‘ë™ì„ ì‹œí‚¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. 

##### 2. ì ‘ê·¼ ë°©ì‹
- left childë¶€í„° íŒŒê³  ë“¤ê¸°   
- right childë¶€í„° íŒŒê³  ë“¤ê¸°   

##### 3. ë°©ë¬¸ ë°©ì‹
- ì „ìœ„ìˆœíšŒ(preorder) : child ì ‘ê·¼ ì „ ë°©ë¬¸ <span style="color:#ff0000">A B D G H E C F</span>   
- ì¤‘ìœ„ìˆœíšŒ(inorder) : left ìš°ì„  ì ‘ê·¼ë°©ì‹ì´ë©´, right child ì ‘ê·¼ ì „ ë°©ë¬¸ <span style="color:#ff0000">G D H B E A C F</span>
- **<u>í›„íœ˜ìˆœíšŒ(postorder)</u>** : child ì ‘ê·¼ í›„ ë°©ë¬¸ <span style="color:#ff0000">G H D E B F C A</span> 
<img src="/assets/images/2023-04-08-tree/visit.png" alt="ë°©ë¬¸ ë°©ì‹" style="zoom:80%;" /> <br/>
  
#### (5) Treeë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°

> Tree êµ¬í˜„   
> Tree ìˆœíšŒ â­
> - level order (BFS)    
> - post order (DFS)     

##### ğŸ“ [Lowest Common Ancestor ë¬¸ì œ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

- ì ‘ê·¼ ë°©ë²• : pì™€ qì˜ ë¶€ëª¨ ë…¸ë“œì˜ ê³µí†µ ë¶„ëª¨ ì¤‘ ê°€ì¥ ì‘ì€ ê±° êµ¬í•´ì•¼ í•˜ë‹ˆê¹Œ, ì•„ë˜ì—ì„œ ì •ë³´ê°€ ì˜¬ë¼ì™€ì•¼ í•©ë‹ˆë‹¤.   

<img src="/assets/images/2023-04-08-tree/lowest.png" alt="ì ‘ê·¼ ë°©ë²•" style="zoom:30%;" />
- **<u>postorder ìˆœíšŒ ë°©ì‹</u>**    
- ì‹œê°„ ë³µì¡ë„ : ìˆœíšŒ O(n)  

```python
# from collections import deque
# # Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# # Make tree.
# def array2tree(arr):
#     q = deque()
#     root = TreeNode(arr[0])
#     q.append(root)

#     idx = 1
#     while idx < len(arr):
#         cur_node = q.popleft()

#         # left node
#         if arr[idx] != None:
#             cur_node.left = TreeNode(arr[idx])
#             q.append(cur_node.left)
#         idx += 1

#         # right node
#         if arr[idx] != None:
#             cur_node.right = TreeNode(arr[idx])
#             q.append(cur_node.right)
#         idx += 1
#     return root

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: int, q: int) -> int:
        if root is None:
            return None
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if root.val == p or root.val == q:      # rootëŠ” cur_node
            return root.val                     # leetcodeì—ì„œëŠ” pì™€ qê°€ intê°€ ì•„ë‹Œ TreeNodeì´ë¯€ë¡œ rootë¥¼ ë¦¬í„´í•´ì•¼ í•¨.
        elif left and right:
            return root.val
        return left or right


root = array2tree([3,5,1,6,2,0,8,None,None,7,4])
sol = Solution()
print(sol.lowestCommonAncestor(root, 5,1))   
```
<br/>

##### ğŸ“ [Max Depth ë¬¸ì œ](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- ì ‘ê·¼ ë°©ë²• 1 : ìœ„ì—ì„œ ì•„ë˜ë¡œ depth += 1  
- **<u>Level order (BFS)</u>**   
- ì‹œê°„ ë³µì¡ë„ : ìˆœíšŒ O(n)   
```python
class Solution:
    def maxDepth(self, root) -> int:
        max_depth = 0
        if root == None: 
            return max_depth
        q = deque()
        q.append((root, 1))
        
        while q:
            cur, depth = q.popleft()
            if cur.left:
                q.append((cur.left, depth+1))   # ë°©ë¬¸ì˜ˆì•½
            if cur.right:
                q.append((cur.right, depth+1))  # ë°©ë¬¸ì˜ˆì•½
            max_depth = max(max_depth, depth)
        return max_depth
```
<br/>

- ì ‘ê·¼ ë°©ë²• 2 : ì•„ë˜ì—ì„œ ìœ„ë¡œ depth += 1 
- **<u>Post order (DFS)</u>**   
- ì‹œê°„ ë³µì¡ë„ : ìˆœíšŒ O(n)   
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0
        
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return max(left_depth, right_depth) + 1
```

**<u> ì–´ë–¤ ìˆœíšŒë“  ì‹œê°„ë³µì¡ë„ëŠ” O(n) ì…ë‹ˆë‹¤.</u>**
<br/>

ë‹¤ìŒì—ëŠ” Graphì— ëŒ€í•´ì„œ í¬ìŠ¤íŒ… í•˜ê² ìŠµë‹ˆë‹¤ :)    

*í•´ë‹¹ ì‹œë¦¬ì¦ˆì˜ í¬ìŠ¤íŠ¸ëŠ” [ì¸í”„ëŸ°ì—ì„œ ì œê³µí•˜ëŠ” ê°œë°œë‚¨ë…¸ì”¨ì˜ ì½”ë”©í…ŒìŠ¤íŠ¸ ê°•ì˜](https://www.inflearn.com/course/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%85%EB%AC%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC) ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.*