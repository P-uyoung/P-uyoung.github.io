---
layout: single  
title:  "Greedy Algorithm"
categories: Algorithm
tag: [Queu]
# toc: true
# toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

**부분적인 최적해가 전체적인 최적해가 되는 경우**
-

<br/>

## 1. 두 큐 합 같게 하기 (카카오_2020_level2)
큐와 포인터 2개

```python
def solution(que1, que2):
    que_sum = (sum(que1)+sum(que2))

    if que_sum % 2 != 0:
        return -1
    
    target = que_sum/2
    cur = sum(que1)

    que3 = que1 + que2
    start = 0
    end = len(que1) -1
    
    answer = 0  

    while(cur != target):
        if cur < target:
            end += 1
            if end == len(que3): 
                return -1
            cur += que3[end]

        else:
            cur -= que3[start]
            start += 1
        answer += 1

    return answer
```
<br/>

## 2. 구명보트에 구출하기

투포인트 문제
```python
def solution(people, limit) :
    answer = 0
    people.sort()

    a = 0
    b = len(people) - 1
    while a < b :
        if people[b] + people[a] <= limit :
            a += 1
            answer += 1
        b -= 1
    return len(people) - answer
```
<br/>

## 3. 조이스틱 최소작동 (프로그래머스_level2)

- 인덱스가 거리 개념

- start = index 0

- end = 포인터 2개 (왼쪽, 오른쪽)

```python
# idx : 오른쪽에서 꺾거나 끝낼 인덱스
# n - next_idx : 왼쪽에서 꺾거나 끝낼 인덱스
# distance : 최소 되돌아갈 거리 

def solution(name):
    answer = 0
    n = len(name)

    def alphabet_to_num(char):
        num_char = [i for i in range(14)] + [j for j in range(12, 0, -1)]
        return num_char[ord(char) - ord('A')]

    for i in name:
        answer += alphabet_to_num(i)
    
    move = n-1
    for idx in range(n):
        next_id = idx + 1
        while (next_id < n) and (name[next_id]=='A'):
            next_id += 1
        distance = min(idx, n - next_idx)
        move = min(move, idx + n - next_idx + distance)
    
    answer += move
    return answer
```
<br/>

## 4. k개 빼서 큰 수 만들기

순서대로 빼야 한다면, 바로 옆에 값만 비교하면 된다.

- (나의 오답) 효율성 문제
```python
def solution(number, k):
    n = len(number)- k
    answer = ''
    limit = -1
    dic = {}
    for i, j in enumerate(number):
        dic[i] = int(j)

    while n != 0:
        max_value = -1
        max_key = -1
        for key, value in dic.items():
            if (len(number)-key >= n) and (max_value < value):
                max_value = value
                max_key = key   
        answer += str(max_value)
        n -= 1

        for i in range(limit+1, max_key+1):
            del dic[i]
        limit = max_key
                
    return answer
```

- 정답
```python
def solution(number, k):
    stack = []
    for num in number:
        while len(stack) > 0 and stack[-1] < num and k > 0:
            k -= 1
            stack.pop()
        stack.append(num)
    
    # 제거 횟수 다 사용하지 않았을 때, 남은 횟수만큼 리스트 뒷자리 잘라내기
    if k != 0:          
        stack = stack[:-k]

    return ''.join(stack)
```