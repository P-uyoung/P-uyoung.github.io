---
layout: single  
title:  "DFS"
categories: Algorithm
tag: [product]
# toc: true
# toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

**DFS를 사용하여 모든 경우를 고려하지만, 적절한 종료조건을 주어야 한다.**


## [1. 타겟 넘버 (프로그래머스_level2)](https://school.programmers.co.kr/learn/courses/30/lessons/43165)

**(1) 나의 풀이**

- 중복순열 

```python
from itertools import permutations, combinations, product, combinations_with_replacement

# (1) 순열(permutations)
a = list(permutations(['A', 'B', 'C'], 2))
print(a)    # nPr, [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

# (2) 조합(combinations)
a = list(combinations(['A','B','C'], 2))
print(a)    # nCr, [('A', 'B'), ('A', 'C'), ('B', 'C')]

# (3) 중복순열(product)
a = list(product(['A','B','C'], repeat=4))
print(a)    # nPir

# (4) 중복조합(combinations_with_replacement)
a = list(combinations_with_replacement(['A','B','C'], 2))
print(a)    # nHr
```

```python
import copy
from itertools import product

def solution(numbers, target):
    arr = list(product([1,-1], repeat=len(numbers)))
    result = []
    for i in range(len(arr)):
        result.append(sum([x*y for x,y in zip(numbers, arr[i])]))

    return result.count(target)
```

**(2) (정석)DFS**

```python
answer = 0
def dfs(idx, numbers, target, value):
    global answer
    N = len(numbers)
    if idx==N and value == target:
        answer += 1
        return
    if idx == N:
        return
    dfs(idx+1, numbers, target, value+numbers[idx])
    dfs(idx+1, numbers, target, value-numbers[idx])

def solution(numbers, target):
    dfs(0, numbers, target, 0)

return answer
```
<br/>

## [2. 게임맵 최단거리 (프로그래머스_level2)](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

**DFS 문제**

```python
def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]
    x_h, y_h = len(maps[0]), len(maps)
    que = [[0,0,1]]    
    
    while que:
        x, y, d = que.pop(0)
        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]
            
            if (0<=nx<x_h) and (0<=ny<y_h):
                if maps[ny][nx] == 1 or maps[ny][nx] > d+1: # maps[ny][nx]는 다른 경로일 때도 고려한 것.
                    maps[ny][nx] = d+1
                    if nx == x_h-1 and ny == y_h-1:
                        return d+1
                    
                    que.append((nx,ny,d+1))
                    
    return -1
```

