---
layout: single  
title:  "(7) Graph"
categories: ì½”í…Œ
tag: [BFS, DFS, Number of Islands, Shortest Path, keys and rooms]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
header:
#   overlay_image: /assets/images/teaser/CT.webp
#   overlay_filter: 0.5
  teaser: /assets/images/teaser/CT.webp
---

### GraphëŠ” <u>treeë³´ë‹¤ ë” í° ê°œë…</u>ìœ¼ë¡œ ì •ì (vertex)ë“¤ì˜ ì§‘í•© Vì™€ ì´ë¥¼ ì—°ê²°í•˜ëŠ” ê°„ì„ (edges)ë“¤ì˜ ì§‘í•© Eë¡œ êµ¬ì„±ëœ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. 

GraphëŠ” íŠ¸ë¦¬ì™€ ë‹¬ë¦¬ <u>ë°©ë¬¸ í‘œì‹œ</u>ë¥¼ í•´ì•¼í•©ë‹ˆë‹¤. BFSì™€ DFS ëª¨ë‘. 

### ì‹œê°„ë³µì¡ë„ëŠ” ì™„ì „íƒìƒ‰ì´ë‹ˆê¹Œ O(n)ì¸ë°, ì‚¬ì‹¤ <u>O(n+E)</u> ì…ë‹ˆë‹¤. 

ëª¨ë“  ì •ì ì— í•œ ë²ˆë§Œ ë°©ë¬¸í•œë‹¤ê³  í•´ë„, ê°„ì„ ë§Œí¼ ê°ˆ ì§€ ë§ì§€ ê²°ì •í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.  

ë‹¤ë§Œ, ìµœë‹¨ê±°ë¦¬ ë¬¸ì œëŠ” BFSë¡œ í’€ ë•Œ ëª¨ë‘ íƒìƒ‰í•˜ê¸° ì „ì— ëë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ, ìµœë‹¨ê±°ë¦¬ ë¬¸ì œëŠ” BFSë¡œ í’€ì–´ì•¼ íš¨ìœ¨ì ì…ë‹ˆë‹¤.  


#### í˜„ì‹¤ì„¸ê³„ì˜ ì—°ê²°ê´€ê³„ë¥¼ ê·¸ë˜í”„ë¡œ í‘œí˜„ 
<img src="/assets/images/2023-04-10-graph/ê·¸ë˜í”„ í™œìš©.png" alt="ê·¸ë˜í”„ í™œìš©" style="zoom:50%;" /> <br/>

#### (1) Graph ì¢…ë¥˜

ì½”í…Œì— ë‚˜ì˜¤ëŠ” ê·¸ë˜í”„ëŠ” ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤! 

- ë°©í–¥ ê·¸ë˜í”„ vs <span style='background-color:#F7DDBE'>ë¬´í–¥ ê·¸ë˜í”„</span>   
- ë‹¤ì¤‘ ê·¸ë˜í”„ vs <span style='background-color:#F7DDBE'>ë‹¨ìˆœ ê·¸ë˜í”„ (ë‘ ì •ì ì˜ ê°„ì„ ì€ í•˜ë‚˜)</span>   
- <span style='background-color:#F7DDBE'>ê°€ì¤‘ì¹˜ ê·¸ë˜í”„</span> => ë‹¤ìµìŠ¤íŠ¸ë¼    
<br/>

#### (2) Graph í‘œí˜„ ë°©ë²•

ê·¸ë˜í”„ëŠ” 3ê°€ì§€ë¡œ í‘œí˜„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

##### 1. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (adjacency list) â­  

ê·¸ë˜í”„ë¥¼ ê°€ì¥ íš¨ìœ¨ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ê¸° ë•Œë¬¸ì—, ê°€ì¥ ë§ì´ ì“°ì…ë‹ˆë‹¤.  
ë³´í†µ ê·¸ë˜í”„ëŠ” ì •ì ì˜ ìˆ˜ì— ë¹„í•´ ê°„ì„ ì´ ì ê¸° ë•Œë¬¸ì´ì£ !

##### 2. ì¸ì ‘ í–‰ë ¬ (adjacency matrix)

ì •ì ì˜ ê°œìˆ˜ë§Œí¼ 2ì°¨ì› ë°°ì—´ì„ ë§Œë“¤ì–´ì„œ í‘œí˜„í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.  

##### 3. ì•”ì‹œì  í–‰ë ¬ (implicit graph) â­
 
(0,0)~(n-1,n-1)ê¹Œì§€ì˜ ê²½ë¡œ, ë„í˜•ë©´ì  êµ¬í•˜ê¸° ë¬¸ì œ ë“±        
**<u>Binary matrixì´ì§€ë§Œ, ìœ„ì•„ë˜ì–‘ì˜† ë°©í–¥ìœ¼ë¡œ ê°„ì„ ì´ ì—°ê²°ë˜ì–´ìˆëŠ” graph</u>**ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.      
<img src="/assets/images/2023-04-10-graph/ì•”ì‹œì  ê·¸ë˜í”„.png" alt="ì•”ì‹œì  ê·¸ë˜í”„" style="zoom:50%;" />       
ê·¸ë˜í”„ ë¬¸ì œì—ì„œ ê°€ì¥ ë§ì´ ë‚˜ì˜¤ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
<br/>

#### (3) BFS   
**<u>BFSëŠ” ë¬¼ìˆ˜ì œë¹„ í˜„ìƒ</u>**ì´ë¼ê³  ìƒê°í•˜ë©´ ì‰½ìŠµë‹ˆë‹¤.  
BFSì™€ DFS ëª¨ë‘ Graphì˜ ì •ì ì„ ì™„ì „íƒìƒ‰í•˜ëŠ” ë°©ë²•ì´ë¯€ë¡œ, BFSë¡œ í’€ì–´ë„ ë˜ê³  DFSë¡œ í’€ì–´ë„ ë©ë‹ˆë‹¤.  

í•˜ì§€ë§Œ, BFSëŠ” ë¬¼ìˆ˜ì œë¹„ì²˜ëŸ¼ ê°€ê¹Œìš´ ê²ƒë¶€í„° ì°¨ë¡€ë¡œ íƒìƒ‰í•˜ë¯€ë¡œ **<u>ìµœë‹¨ê±°ë¦¬ ë¬¸ì œì—ì„œëŠ” BFSë¡œ í‘¸ëŠ” ê²ƒì´ íš¨ìœ¨ì </u>**ì…ë‹ˆë‹¤.    
DFSëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‹¤ ì‹œë„í•´ì•¼ ì•Œ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.   

<img src="/assets/images/2023-04-10-graph/bfs.png" alt="BFS" style="zoom:20%;" /> <br/>      

##### ê·¸ë˜í”„ BFSì˜ í…œí”Œë¦¿ â­
```python
from collections import deque
# ê·¸ë˜í”„, ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„
graph = {
    'A' : ['B', 'D', 'E'],
    'B' : ['A', 'C', 'D'],
    'C' : ['B'],
    'D' : ['A', 'B'],
    'E' : ['A']
}

def bfs(graph, start_v):
    q = deque(start_v)
    visited = [start_v]
    while q:
        cur_v = q.popleft()
        for nex_v in graph[cur_v]:
            if nex_v not in visited:
                q.append(nex_v)
                visited.append(nex_v)   # ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë°©ë¬¸ì˜ˆì•½ ì‹œ visited í•´ì•¼í•¨.

    return visited

print(bfs(graph, 'A'))  # ['A', 'B', 'D', 'E', 'C']
```
<br/>

#### (4) DFS  
DFSëŠ” **<u>ë£¨íŠ¸ ì •ì ì˜ ì—°ê²° ì •ì ì„ subgraphì˜ ìƒˆë¡œìš´ ë£¨íŠ¸ ì •ì ìœ¼ë¡œ ë³´ê³ , ì¬ê·€ë¡œ ë¬¸ì œë¥¼ ìª¼ê°œì„œ</u>** ìƒê°í•©ë‹ˆë‹¤.   

##### ê·¸ë˜í”„ DFSì˜ í…œí”Œë¦¿ â­
```python
from collections import deque
graph = { ... }
visited = []

def dfs(root):
    visited.append(root)
    for v in graph[root]:
        if v not in visited:
            dfs(v)
dfs('A')
print(visited)  #['A', 'B', 'C', 'D', 'E']
```
<br/>

#### (5) ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°   

> Graph êµ¬í˜„   
> **<u>BFS ë„ˆë¹„ ìš°ì„  íƒìƒ‰</u>**   
> **<u>DFS ê¹Šì´ ìš°ì„  íƒìƒ‰</u>**     


##### ğŸ“ [Number of Islands ë¬¸ì œ](https://leetcode.com/problems/number-of-islands/)

- ì œí•œ ì‚¬í•­ : 1 <= grid.length, grid[i].length <= 300    
- ì ‘ê·¼ ë°©ë²• : ì„¬ì€ ìƒ‰ì¹ , ìƒˆë¡œìš´ ì„¬ ë°œê²¬? ë˜ ìƒ‰ì¹     
- **<u>BFS</u>**      
- ì‹œê°„ ë³µì¡ë„ : ìˆœíšŒ O(n) (ëŒ€ëµ 10^5)   

```python
from collections import deque 
class Solution(object):
    def numIslands(self, grid):
        m = len(grid) 
        n = len(grid[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        islandsN = 0 
        
        # ì—¬ê¸°ì— ì •ì˜í•˜ë©´ í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ë¥¼ ìƒˆë¡œ ë©”ëª¨ë¦¬ì— ì˜¬ë¦¬ì§€ ì•Šì•„ë„ ë¨.
        def bfs(x,y):
            q = deque()                 # íŠœí”Œì€ ì´ˆê¸°í™” ì‹œ ë„£ì„ ìˆ˜ ì—†ìŒ.
            grid[y][x] = '0'
            q.append((x,y))
            while q:
                cur_x, cur_y = q.popleft()
                for i in range(4):
                    nxt_x = cur_x + dx[i]
                    nxt_y = cur_y + dy[i]
                    if nxt_x < 0 or nxt_x >= n or nxt_y < 0 or nxt_y >= m:
                        continue
                    if grid[nxt_y][nxt_x] =='1':
                        grid[nxt_y][nxt_x] = '0'
                        q.append((nxt_x, nxt_y))
            
        for x in range(n):
            for y in range(m):
                if grid[y][x] == '1':
                    islandsN += 1
                    bfs(x,y)
                    # dfs()     
                           
        return islandsN
    
sol = Solution()
print(sol.numIslands([["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]))
```
<br/>

##### ğŸ“ [Shortest Path ë¬¸ì œ](https://leetcode.com/problems/shortest-path-in-binary-matrix/description/)

**<u> ìµœë‹¨ê²½ë¡œ ë¬¸ì œëŠ” BFSê°€ íš¨ìœ¨ì </u>** ì…ë‹ˆë‹¤. DFSë¡œë„ í’€ ìˆ˜ ìˆì§€ë§Œ, ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ í•´ë´ì•¼í•©ë‹ˆë‹¤.   

- ì œí•œ ì‚¬í•­ : 1 <= grid.length, grid[i].length <= 100    
- ì ‘ê·¼ ë°©ë²• : ìµœë‹¨ê²½ë¡œ ë¬¸ì œëŠ”? ë¬´ì¡°ê±´ BFS. ë¨¼ì € ë„ì°©í•œ ê²Œ ìµœë‹¨ê±°ë¦¬ì´ë¯€ë¡œ, shortest ì €ì¥í•  í•„ìš” ì—†ìŒ!   
- **<u>BFS</u>**  
- ì‹œê°„ ë³µì¡ë„ : ìˆœíšŒ O(n)     

```python
from collections import deque
class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1 
        if n == 1:
            return 1
        
        # shortest = [[10001]*n for _ in range(n)]  # BFS ë¨¼ì € ë„ì°©í•œ ê²Œ ìµœë‹¨ê±°ë¦¬ì„. shortest í•„ìš” ì—†ìŒ.
        dx = [0,0,1,-1,1,1,-1,-1]
        dy = [1,-1,0,0,1,-1,1,-1]
        q = deque()
        grid[0][0] = 1                              # ë°©ë¬¸ ì²˜ë¦¬
        q.append((0,0,1))
        
        while q:
            x, y, dist = q.popleft()
            for i in range(8):                      # ë°©ë¬¸ ì˜ˆì•½
                next_x = x + dx[i]
                next_y = y + dy[i]
                if next_x < 0 or next_x >= n or next_y < 0 or next_y >= n:
                    continue
                if grid[next_y][next_x] == 1:
                    continue
                if next_x == n-1 and next_y == n-1:
                    return dist + 1
                else:
                    grid[next_y][next_x] = 1
                    q.append((next_x, next_y, dist+1))
        
        return -1
        

sol = Solution()
print(sol.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]]))
```
<br/>

##### ğŸ“ [keys and rooms ë¬¸ì œ](https://leetcode.com/problems/keys-and-rooms/) â­    
- ì œí•œ ì‚¬í•­ : 2 <= rooms.length <= 1000, 1 <= sum(rooms[i].length) <= 3000    
- ì‹œê°„ ë³µì¡ë„ : O(V+E) = O(4000)

- **<u>BFSë¡œ í’€ë©´ ?</u>**  
```python
from collections import deque
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        visited = [False]*n
        q = deque()
        visited[0] = True
        q.append(0)
        while q:
            v = q.popleft()
            for next_v in rooms[v]:     # keysë¥¼ ì¶”ê°€í•˜ì§€ ì•Šì•„ë„ ë¨
                if not visited[next_v]:
                    visited[next_v] = True
                    q.append(next_v)
        
        if all(visited) :
            return True
        else:
            return False
```

- **<u>DFSë¡œ í’€ë©´ ?</u>**       

```python
class Solution:
    def canVisitAllRooms(self, rooms) -> bool:
        n = len(rooms)
        visited = [False]*n

        def dfs(v):
            visited[v] = True
            for next_v in rooms[v]:      # keysë¥¼ ì¶”ê°€í•˜ì§€ ì•Šì•„ë„ ë¨
                if not visited[nex_v]:
                    dfs(next_v)
         
        dfs(0) 

        if all(visited):
            return True
        else:
            return False

sol = Solution()
sol.canVisitAllRooms([[1],[2],[3],[]])
```
<br/>

**<u> BFS, DFSì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(n) ì…ë‹ˆë‹¤.</u>**
<br/>

ë‹¤ìŒì—ëŠ” ë§ì´ ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ DPì— ëŒ€í•´ì„œ í¬ìŠ¤íŒ… í•˜ê² ìŠµë‹ˆë‹¤ :)    

*í•´ë‹¹ ì‹œë¦¬ì¦ˆì˜ í¬ìŠ¤íŠ¸ëŠ” [ì¸í”„ëŸ°ì—ì„œ ì œê³µí•˜ëŠ” ê°œë°œë‚¨ë…¸ì”¨ì˜ ì½”ë”©í…ŒìŠ¤íŠ¸ ê°•ì˜](https://www.inflearn.com/course/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%85%EB%AC%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC) ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.*