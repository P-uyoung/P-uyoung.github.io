---
layout: single  
title:  "BFS"
categories: Algorithm
tag: []
# toc: true
# toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

## [1. 경주로 건설](https://school.programmers.co.kr/learn/courses/30/lessons/67259) (level_3)

**BFS + 메모이제이션(DP)**

```python
def solution(board):
    answer = 400000
    N = len(board)
    dp = [[[400000 for i in range(N)] for i in range(N)] for i in range(4)]
    directions = [(0, 1, 0), (1, 0, 1), (0, -1, 2), (-1, 0,3)]
    q = []
    q.append((0,0,1,0)) # (x,y,dir,cost)
    q.append((0,0,0,0))
    
    while q:
        x,y,d,c= q.pop(0)
        for i in directions:
            nx = x + i[0]
            ny = y + i[1]
            if 0<=nx<=N-1 and 0<=ny<=N-1 and board[ny][nx] == 0:
                add = 100 if d==i[2] else 600
                if dp[i[2]][ny][nx] > c+add:
                    dp[i[2]][ny][nx] = c+add
                    # if nx == N-1 and ny==N-1:
                    #     continue
                    q.append((nx,ny, i[2], dp[i[2]][ny][nx]))
    for i in range(4):
        answer = min(answer,dp[i][N-1][N-1])
    return answer
```
<br/>

## [2. 게임 맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) (level_2)

```python
from collections import deque

def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]

    x_h, y_h = (len(maps[0]), len(maps))
    queue = deque([(0, 0, 1)])

    while queue:
        x, y, d = queue.popleft()

        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]

            if nx > -1 and ny > -1 and nx < x_h and ny < y_h:
                if maps[ny][nx] == 1 or maps[ny][nx] > d + 1:
                    maps[ny][nx] = d + 1
                    if nx == x_h - 1 and ny == y_h - 1:
                        return d + 1

                    queue.append((nx, ny, d + 1))

    return -1
```
<br/>

## [3. 단어 변환](https://school.programmers.co.kr/learn/courses/30/lessons/43163) (level_3)

나는 처음에, DFS로 풀었다.

하지만, 효율성 측면에서 BFS로 풀 수 있으면 BFS로 푸는 것이 바람직하다.

첫 후보가, 다음 후보 다음으로 있는가? 없는가? / 

**-자료구조 : Generator, Dictionary**

**-zip() 함수를 사용하여, 두 문자열 비교**

**visited가 아닌, dist 개념으로 풂**

```python
def get_next(cur, words):
    for nxt in words:
        count = 0
        for c, n in zip(cur, nxt):
            if c != n:
                count += 1
            if count > 1:
                break
        if count == 1:
            yield nxt

def solution(begin, target, words):
    dist = {begin:0}
    q = []
    q.append(begin)

    while q:
        cur = q.pop(0)

        for nxt in get_next(cur, words):
            if nxt not in dist:
                dist[nxt] = dist[cur] + 1
                q.append(nxt)
    return dist.get(target, 0)
```
<br/>