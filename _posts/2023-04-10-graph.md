---
layout: single  
title:  "Graph"
categories: Coding
tag: [BFS, DFS]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---

###   
#### (1) 

<img src="/assets/images/2023-04-08-tree/recursive.png" alt="재귀함수" style="zoom:80%;" /> <br/>

##### 1. 
#### (5) Graph를 사용하는 경우

>     

##### 🍓 [ 문제]()

- 제한 사항 :
- 접근 방법 :
- BFS 
- 시간 복잡도 : 순회 O(n)  

```python
from collections import deque 
class Solution(object):
    def numIslands(self, grid):
        m = len(grid) 
        n = len(grid[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        islandsN = 0 
        
        # 여기에 정의하면 함수의 파라미터를 새로 메모리에 올리지 않아도 됨.
        def bfs(x,y):
            q = deque()
            grid[y][x] = '0'
            q.append((x,y))
            while q:
                cur_x, cur_y = q.popleft()
                for i in range(4):
                    nxt_x = cur_x + dx[i]
                    nxt_y = cur_y + dy[i]
                    if nxt_x < 0 or nxt_x >= n or nxt_y < 0 or nxt_y >= m:
                        continue
                    if grid[nxt_y][nxt_x] =='1':
                        grid[nxt_y][nxt_x] = '0'
                        q.append((nxt_x, nxt_y))
            
        for x in range(n):
            for y in range(m):
                if grid[y][x] == '1':
                    islandsN += 1
                    bfs(x,y)
                    # dfs()     
                           
        return islandsN
    
sol = Solution()
print(sol.numIslands([["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]))
```
<br/>

##### 🍓 [ 문제]()

**<u> 최단경로 문제는 BFS가 효율적</u>** 입니다. DFS로도 풀 수 있지만, 모든 경우의 수를 해봐야합니다.   

- 제한 사항 :
- 접근 방법 :
- BFS 
- 시간 복잡도 : 순회 O(n)  

```python
from collections import deque
class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1 
        if n == 1:
            return 1
        
        # shortest = [[10001]*n for _ in range(n)]  # BFS 먼저 도착한 게 최단거리임. shortest 필요 없음.
        dx = [0,0,1,-1,1,1,-1,-1]
        dy = [1,-1,0,0,1,-1,1,-1]
        q = deque()
        grid[0][0] = 1                              # 방문 처리
        q.append((0,0,1))
        
        while q:
            x, y, dist = q.popleft()
            for i in range(8):                      # 방문 예약
                next_x = x + dx[i]
                next_y = y + dy[i]
                if next_x < 0 or next_x >= n or next_y < 0 or next_y >= n:
                    continue
                if grid[next_y][next_x] == 1:
                    continue
                if next_x == n-1 and next_y == n-1:
                    return dist + 1
                else:
                    grid[next_y][next_x] = 1
                    q.append((next_x, next_y, dist+1))
        
        return -1
        

sol = Solution()
print(sol.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]]))
```

<br/>

##### 🍓 [ 문제]()

- 제한 사항 :
- 접근 방법 :
- BFS 
- 시간 복잡도 : 순회 O(n)  


```python
from collections import deque
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        visited = [False]*n
        q = deque()
        visited[0] = True
        q.append((0, rooms[0]))
        while q:
            _, keys = q.popleft()
            for next_room in keys:
                if not visited[next_room]:
                    visited[next_room] = True
                    q.append((next_room, keys+rooms[next_room]))
        
        if all(visited) :
            return True
        else:
            return False
```

다음에는 Graph에 대해서 포스팅 하겠습니다 :)    

*해당 시리즈의 포스트는 [인프런에서 제공하는 개발남노씨의 코딩테스트 강의](https://www.inflearn.com/course/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%85%EB%AC%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC) 를 바탕으로 작성하였습니다.*