---
layout: single  
title:  "(코테) Graph"
categories: Algorithm
tag: [graph]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

# Graph (순환 경로 O)   

<br/>

## 1. [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189) (level3) 

```python
graph = []
dp = []
visited = []

def bfs():
    q = []
    q.append(1)
    
    while q:
        cur = q.pop(0)
        visited[cur] = True
        
        for nxt in graph[cur]:
            if visited[nxt] == False:
                if dp[nxt] == 0 or dp[nxt] > dp[cur]+1:
                    dp[nxt] = dp[cur]+1 
                    q.append(nxt)  
                else:
                    pass
            
def solution(n, vertex):
    for i in range(n+1):
        graph.append([])
        dp.append(0)
        visited.append(False)
        
    for u, v in vertex:
        graph[u].append(v)
        graph[v].append(u)

    # print(graph)
    bfs()
    # print(dp)
    count = max(dp)
    answer = dp.count(count)

    return answer
```


# Tree

## 1. [1. 전력망 나누기 (프로그래머스_level2)](https://school.programmers.co.kr/learn/courses/30/lessons/86971)

```python
graph = []
numChild = []

def countChild(v):
    if numChild[v] != -1:
        return numChild[v]

    count = len(graph[v])
    for child in graph[v]:
        count += countChild(child)

    numChild[v] = count
    return count


def bfs(n):
    q = []
    visited = [False for _ in range(n+1)]
    q.append(1)
    visited[1] = True

    while q:
        cur = q.pop(0)
        for nex in graph[cur]:
            q.append(nex)
            visited[nex] = True
            graph[nex].remove(cur)

def solution(n, wires):
    for i in range(n+1):
        graph.append([])
        numChild.append(-1)

    for u, v in wires:
        graph[u].append(v)
        graph[v].append(u)

    bfs(n)
    countChild(1)

    return min(map(lambda v: abs((n-(v+1))-(v+1)), numChild))         # + 1은 parent node와의 연결
```