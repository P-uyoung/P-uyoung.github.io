---
layout: single  
title:  "(코테-BFS) Path 문제"
categories: Algorithm
tag: [3d-array, Dynamic Programming]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

# "목표지점(N-1,N-1)까지의 최단비용"   

**NN배열에 각 지점에 최단비용을 계속해서 업데이트하면서 푸는 문제**
<br/>

## 1. [경주로 건설](https://school.programmers.co.kr/learn/courses/30/lessons/67259) (카카오_level3) 

**BFS+3차원dp** 로 풀기

- 3차원 배열 : arr[층][행][열] (할당할 때의 반대)

```python
from collections import deque

def solution(board):
    result = 10000
    N = len(board)
    direction = [[0, 1, 0], [1, 0, 1], [0, -1, 2], [-1, 0, 3]]
    dp = [[[10000] * N for i in range(N)] for j in range(4)]
    queue = deque()
    queue.append([0, 0, 0, 0])
    queue.append([0, 0, 0, 1])
    while queue:
        x, y, m, d = queue.popleft()
        for i in range(4):
            new_x = x + direction[i][0]
            new_y = y + direction[i][1]
            if -1 < new_x < N and -1 < new_y < N and board[new_x][new_y] == 0:
                new_m = m + 1
                if not d == direction[i][2]:
                    new_m += 5
                if new_m < dp[direction[i][2]][new_x][new_y]:
                    dp[direction[i][2]][new_x][new_y] = new_m
                    if new_x == N-1 and new_y == N-1:
                        continue
                    queue.append([new_x, new_y, new_m, direction[i][2]])
    for i in range(4):
        result = min([result, dp[i][N-1][N-1]])
    return result * 100

# by https://school.programmers.co.kr/questions/25392
```
<br/>

## 2. [게임맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) (level_2)

```python
from collections import deque

def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]

    x_h, y_h = (len(maps[0]), len(maps))
    queue = deque([(0, 0, 1)])

    while queue:
        x, y, d = queue.popleft()

        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]

            if nx > -1 and ny > -1 and nx < x_h and ny < y_h:
                if maps[ny][nx] == 1 or maps[ny][nx] > d + 1:
                    maps[ny][nx] = d + 1
                    if nx == x_h - 1 and ny == y_h - 1:
                        return d + 1

                    queue.append((nx, ny, d + 1))

    return -1
```
<br/>

# "도형 테두리문제"

## 1. [아이템 줍기](https://school.programmers.co.kr/learn/courses/30/lessons/87694) (level_3)

**Input size : x<=50, y<=50, n(작은 사각형 개수)<=4**

### (1) next가 테두리인지 그때그때 판단  

**시간 복잡도 : O((x+y)n^2)** 

둘레를 따라서 1칸씩 이동하면서 <u>한 바퀴를 돌아,</u> 전체 둘레 길이와 아이템까지의 거리를 재는 방식   

1칸씩 이동할 때마다, 둘레 위의 점인지 확인하는 방법으로, 시간 복잡도는 둘레의 길이(x+y)n에 둘레 점을 판단하는 n을 곱한 값이다.    

여기서는, 점을 1/2 한다. (이유 맨 아래와 같음.)

```python
import itertools

def is_movable(cur_x, cur_y, next_x, next_y, rectangles):
    x, y = (cur_x + next_x) / 2, (cur_y + next_y) / 2
    is_on_any_border = any(
        (x in (x1, x2) and y1 <= y <= y2) or (y in (y1, y2) and x1 <= x <= x2)
        for x1, y1, x2, y2 in rectangles)
    is_inside_any_rect = any(
        x1 < x < x2 and y1 < y < y2 for x1, y1, x2, y2 in rectangles)
    return is_on_any_border and not is_inside_any_rect


def solution(rectangle, characterX, characterY, itemX, itemY):
    cur_pos = (characterX, characterY)
    prev_pos = None
    for dist in itertools.count():  # 무한반복+count
        if cur_pos == (characterX, characterY) and prev_pos:    #prev_pos, 0빼고 다 true
            total = dist    
            break
        elif cur_pos == (itemX, itemY):
            dist_to_item = dist

        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            next_pos = (cur_pos[0] + dx, cur_pos[1] + dy)
            if next_pos != prev_pos and is_movable(*cur_pos, *next_pos,
                                                   rectangle):
                print(next_pos)
                prev_pos, cur_pos = cur_pos, next_pos
                break
    return min(dist_to_item, total - dist_to_item)

http://www.teferi.net/ps/problems/programmers/87694
```

### (2) 테두리 배열로 미리 구함

**시간 복잡도 : O((x+y)n)**     

여기서는, 테두리 배열을 2배한다. (이유 맨 아래와 같음.)
```python
from collections import deque

def solution(rectangle, characterX, characterY, itemX, itemY):
    answer = 0
    
    # 제한사항에서 모든 좌표값은 1 이상 50 이하라고 했고 2배의 좌표를 그려야 하므로 102*102 크기의 2차원 배열 선언
    field = [[-1] * 102 for i in range(102)]
    
    # 직사각형 그리기
    for r in rectangle:
    	# 모든 좌표값 2배
        x1, y1, x2, y2 = map(lambda x: x*2, r)
        # x1부터 x2, y1부터 y2까지 순회
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
            	# x1, x2, y1, y2는 테두리이므로 제외하고 내부만 0으로 채움
                if x1 < i < x2 and y1 < j < y2:
                    field[i][j] = 0
                # 다른 직사각형의 내부가 아니면서 테두리일 때 1로 채움
                elif field[i][j] != 0:
                    field[i][j] = 1
                    
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    
    # 큐에 캐릭터 출발지점 추가 & 최단거리를 적어줄 visited 배열 선언
    q = deque()
    q.append([characterX * 2, characterY * 2])
    visited = [[1] * 102 for i in range(102)]
    
    while q:
        x, y = q.popleft()
        # 도착한 곳이 아이템이 있는 장소라면 현재의 최단거리(나누기 2)를 answer로 하고 while문을 빠져나옴
        if x == itemX * 2 and y == itemY * 2:
            answer = visited[x][y] // 2
            break
        # 아니라면 상하좌우 네 방향을 체크하면서
        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]
            # 현재 좌표가 테두리이고 아직 방문하지 않은 곳이라면 q에 추가 후 visited 최단거리로 갱신
            if field[nx][ny] == 1 and visited[nx][ny] == 1:
                q.append([nx, ny])
                visited[nx][ny] = visited[x][y] + 1
    
    return answer
```

### (고려 사항) 좌표로 길을 탐색
https://taehoung0102.tistory.com/95    

<img src="/assets/images/2023-02-21-Path/multiply_or_divide_2.png" alt="multiply_or_divide_2." width="445.9" height="833.7"/>







