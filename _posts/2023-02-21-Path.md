---
layout: single  
title:  "(코테-BFS) Path 문제"
categories: Algorithm
tag: [3d-array, Dynamic Programming]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

# "목표지점(N-1,N-1)까지의 최단비용"   

**NN배열에 각 지점에 최단비용을 계속해서 업데이트하면서 푸는 문제**
<br/>

## 1. [경주로 건설](https://school.programmers.co.kr/learn/courses/30/lessons/67259) (카카오_level3) 

**BFS+3차원dp** 로 풀기

- 3차원 배열 : arr[층][행][열] (할당할 때의 반대)

```python
from collections import deque

def solution(board):
    result = 10000
    N = len(board)
    direction = [[0, 1, 0], [1, 0, 1], [0, -1, 2], [-1, 0, 3]]
    dp = [[[10000] * N for i in range(N)] for j in range(4)]
    queue = deque()
    queue.append([0, 0, 0, 0])
    queue.append([0, 0, 0, 1])
    while queue:
        x, y, m, d = queue.popleft()
        for i in range(4):
            new_x = x + direction[i][0]
            new_y = y + direction[i][1]
            if -1 < new_x < N and -1 < new_y < N and board[new_x][new_y] == 0:
                new_m = m + 1
                if not d == direction[i][2]:
                    new_m += 5
                if new_m < dp[direction[i][2]][new_x][new_y]:
                    dp[direction[i][2]][new_x][new_y] = new_m
                    if new_x == N-1 and new_y == N-1:
                        continue
                    queue.append([new_x, new_y, new_m, direction[i][2]])
    for i in range(4):
        result = min([result, dp[i][N-1][N-1]])
    return result * 100

# by https://school.programmers.co.kr/questions/25392
```
<br/>

## 2. [게임맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) (level_2)

```python
from collections import deque

def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]

    x_h, y_h = (len(maps[0]), len(maps))
    queue = deque([(0, 0, 1)])

    while queue:
        x, y, d = queue.popleft()

        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]

            if nx > -1 and ny > -1 and nx < x_h and ny < y_h:
                if maps[ny][nx] == 1 or maps[ny][nx] > d + 1:
                    maps[ny][nx] = d + 1
                    if nx == x_h - 1 and ny == y_h - 1:
                        return d + 1

                    queue.append((nx, ny, d + 1))

    return -1
```
<br/>

# "도형 테두리문제"

## 1. [아이템 줍기](https://school.programmers.co.kr/learn/courses/30/lessons/87694) (level_3)

**Input size : x<=50, y<=50, n(작은 사각형 개수)<=4**

### (1) next가 테두리인지 그때그때 판단  

**시간 복잡도 : O((x+y)n^2)** 

둘레를 따라서 1칸씩 이동하면서 <u>한 바퀴를 돌아,</u> 전체 둘레 길이와 아이템까지의 거리를 재는 방식   

1칸씩 이동할 때마다, 둘레 위의 점인지 확인하는 방법으로, 시간 복잡도는 둘레의 길이(x+y)n에 둘레 점을 판단하는 n을 곱한 값이다.    

여기서는, 점을 1/2 한다. (이유 맨 아래와 같음.)

```python
import itertools 

def is_edge(cur_x, cur_y, nxt_x, nxt_y, rectangles):
    x, y = 


http://www.teferi.net/ps/problems/programmers/87694
```

### (2) 테두리 배열로 미리 구함

**시간 복잡도 : O((x+y)n)**     

여기서는, 테두리 배열을 2배한다. (이유 맨 아래와 같음.)


### (고려 사항) 좌표로 길을 탐색
<img src="/assets/iimages/2023-02-21-Path/multiply_or_divide_2.png" alt="multiply_or_divide_2."/>






