---
layout: single  
title:  "(코테-BFS) Path 문제"
categories: Algorithm
tag: [3d-array, Dynamic Programming]
# toc: true
# toc_sticky: true
author_profile: false
search: true
use_math: true
---
<br/>

## "목표지점(N-1,N-1)까지의 최단비용은 N*N배열에 각 지점에 최단비용을 계속해서 업데이트하면서 푸는 문제"
<br/>

## 1. [경주로 건설](https://school.programmers.co.kr/learn/courses/30/lessons/67259) (카카오_level3) 

**BFS+3차원dp** 로 풀기

- 3차원 배열 : arr[층][행][열] (할당할 때의 반대)

```python
from collections import deque

def solution(board):
    result = 10000
    N = len(board)
    direction = [[0, 1, 0], [1, 0, 1], [0, -1, 2], [-1, 0, 3]]
    dp = [[[10000] * N for i in range(N)] for j in range(4)]
    queue = deque()
    queue.append([0, 0, 0, 0])
    queue.append([0, 0, 0, 1])
    while queue:
        x, y, m, d = queue.popleft()
        for i in range(4):
            new_x = x + direction[i][0]
            new_y = y + direction[i][1]
            if -1 < new_x < N and -1 < new_y < N and board[new_x][new_y] == 0:
                new_m = m + 1
                if not d == direction[i][2]:
                    new_m += 5
                if new_m < dp[direction[i][2]][new_x][new_y]:
                    dp[direction[i][2]][new_x][new_y] = new_m
                    if new_x == N-1 and new_y == N-1:
                        continue
                    queue.append([new_x, new_y, new_m, direction[i][2]])
    for i in range(4):
        result = min([result, dp[i][N-1][N-1]])
    return result * 100

# by https://school.programmers.co.kr/questions/25392
```
<br/>

## 2. [게임맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) (level_2)

```python
from collections import deque

def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]

    x_h, y_h = (len(maps[0]), len(maps))
    queue = deque([(0, 0, 1)])

    while queue:
        x, y, d = queue.popleft()

        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]

            if nx > -1 and ny > -1 and nx < x_h and ny < y_h:
                if maps[ny][nx] == 1 or maps[ny][nx] > d + 1:
                    maps[ny][nx] = d + 1
                    if nx == x_h - 1 and ny == y_h - 1:
                        return d + 1

                    queue.append((nx, ny, d + 1))

    return -1
```