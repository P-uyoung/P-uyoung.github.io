---
layout: single  
title:  "[기업코테 분석] 카카오인턴 2019"
categories: Computer_Vision
tag: [호텔방배정, 징검다리건너기, 불량사용자]
toc: true
toc_sticky: true
author_profile: false
search: true
use_math: true
---

### 5문제 4시간 시험으로, 문제유형은 (이분탐색) 입니다.

[기출문제 해설 공식 블로그](https://tech.kakao.com/2020/04/01/2019-internship-test/)     
문제가 난이도 순으로 나오는 것은 아니네요! 


#### 1. [Lv.4 호텔 방 배정](https://school.programmers.co.kr/learn/courses/30/lessons/64063)



#### 2. [Lv.3 징검다리 건너기](https://school.programmers.co.kr/learn/courses/30/lessons/64062)

- 문제 상황 : 니니지 친구들이 무제한으로 있을 때, 징검다리를 건널 수 있는 친구들의 최대 인원 수를 구하는 문제입니다.  징검다리 돌은 밟을 수 있는 숫자가 각각 정해져 있으며, 0이 되면 밝을 수 없고 다음 돌로 jump할 수 있습니다. jump 가능한 수는 k로 주어집니다.  

- 제한 사항 : 1<= stones의 배열의 길이, k <= 2*10^5 

- 문제 이해 : 0인 징검다리 돌이 k개 연속될 경우, 징검다리 건너기 종료! stones 배열의 길이가 매우 크므로 원소를 하나씩 차감해주면, 타임오버가 걸립니다.    

- **<u>문제 접근 : 이진 탐색 O(logN)</u>**

(1) 나의 풀이 : 정확성 100, 효율성 0

처음에는, 원소를 하나씩 차감하면서, 연속으로 0인 돌이 k가 생기는지 확인하는 방식으로 코드를 짰습니다. 

<details>
<summary>[나의 풀이 접기/펼치기]</summary>
<div markdown="1">

```python
def solution(stones, k):
    answer = 0
    cur = 0
    n = len(stones)
    
    while True:
        if cur == n:
            answer += 1
            cur = 0
        
        if stones[cur] != 0:
            stones[cur] -= 1
        
        else:
            nothing = True
            for i in range(1,k):
                if cur + i == n:
                    answer += 1
                    cur = -1
                    nothing = False
                    break

                if stones[cur+i] != 0:
                    cur += i
                    stones[cur] -= 1
                    nothing = False
                    break
            if nothing:
                break
        
        cur += 1
          
    return answer

```
</div>
</details>
<br/>

(2) 이진탐색으로 풀기 

**<u>O(nlongm), n: 디딤돌개수, m: 디딤돌의 최대값</u>**

```python
# 최소/최대 idx를 가지고, 친구들의 수(M)를 찾기

def solution(stones, k):
    # 예외처리
    if k == 1:
        return min(stones)
    
    # M의 최소와 최대를 setting
    left = 1
    right = max(stones)
        
    # M이 답이라고 할 때, M-1에서 (k-1)개의 연속된 0이 있다. 
    def binaryCheck(mid):
        zeroCount = 0
        for v in stones:
            if v < mid:
                zeroCount += 1
            else:
                zeroCount = 0   # 연속되는 0만 의미가 있으므로
            if zeroCount >= k:  # k-1개까지 가능
                return False
        return True 
    
    while left < right-1 :
        mid = (left+right)//2
        if binaryCheck(mid):
            left = mid
        
        else:
            right = mid
            
    return left
```
<br/>

#### 3. [Lv.3 불량 사용자](https://school.programmers.co.kr/learn/courses/30/lessons/64064)

```python
import copy
def solution(user_id, banned_id):
    n = len(banned_id)
    banned_list = []
    
    def check(u,b):
        n, m = len(u), len(b)
        if n != m:
            return False
        for i, j in zip(u,b):
            if i != j and j != '*':
                return False
        return True
    
    def dfs(user_id, banned_id, id_set):
        if len(id_set) == n :
            if id_set not in banned_list:
                id_set = copy.deepcopy(id_set)  
                banned_list.append(id_set)
            return
           
        if not user_id or not banned_id:
            return

        for i, u in enumerate(user_id):
            if check(u, banned_id[0]):
                id_set.add(u)
                dfs(user_id[:i]+user_id[i+1:], banned_id[1:], id_set)
                id_set.remove(u)
        return 
    
    dfs(user_id, banned_id, set())
    # print(banned_list)
    return len(banned_list)

input1 = [["frodo", "fradi", "crodo", "abc123", "frodoc"],["frodo", "fradi", "crodo", "abc123", "frodoc"],["frodo", "fradi", "crodo", "abc123", "frodoc"]]
input2 = [["fr*d*", "abc1**"],["*rodo", "*rodo", "******"],["fr*d*", "*rodo", "******", "******"]]
for i in range(3):
    print(solution(input1[i],input2[i]))   
```
<br/>

푸는데 세시간 걸렸습니다ㅜㅜ 

헤맨 이유

**(1) 딕셔너리의 key에는 immutable 자료형만 가능함.**

if key in dic: 문법 쓰려고, 처음에는 딕셔너리로 시도했습니다. 

최대길이가 8이므로, 딕셔너리 말고 그냥 list로 풀어도 되서 list로 고쳤습니다. 


**(2) mutable 자료형은 deepcopy 해야 함.**

```python
def solution(user_id, banned_id):
   ...
    
    def check(u,b):
        ...
    
    def dfs(user_id, banned_id, id_set):
        if len(id_set) == n :
            if id_set not in banned_list:
                banned_list.append(id_set)          # 바로 append 하면, dfs의 for문에서 id_set이 바뀔 때 banned_list의 원소도 바뀐다.
                ...

        for i, u in enumerate(user_id):
            if check(u, banned_id[0]):
                id_set.add(u)
                dfs(user_id[:i]+user_id[i+1:], banned_id[1:], id_set)
                id_set.remove(u)
        return 
    ...
```

**(3) 테스트 케이스 5번 시간 초과**

user_id가 banned_id에 중복으로 해당하는 경우 때문에, user_id를 고려하는 순서를 for문을 통해서 바꿔주고,

banned_id의 순서도 for문으로 바꿔줬는데, user_id만 바꿔줬더니 해결됐습니다.

<br/>

만약에,  

userid = ["aaaaaaaa", "bbbbbbbb", "cccccccc", "dddddddd", "eeeeeeee", "ffffffff", "gggggggg", "hhhhhhhh"]

bannedid = [(*8개인 문자열 8개)]

다음과 같은 상황에서, 아래 코드로 짜면 **<u>8!*8!</u>** 로 생각이 됩니다. 그래서 시간 초과가 난 것 같습니다. 

```python
import copy
def solution(user_id, banned_id):
    ...
    
    def check(u,b):
        ...
    
    def dfs(user_id, banned_id, id_set):
       ...

        for i, u in enumerate(user_id):
            for j, b in enumerate(banned_id):
                if check(u, b):
                    id_set.add(u)
                    dfs(user_id[:i]+user_id[i+1:], banned_id[:i]+banned_id[i+1:], id_set)
                    id_set.remove(u)
        return 
    
    ...
```